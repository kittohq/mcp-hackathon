"""
Internal Penetration Testing Agent using NodeZero MCP
Handles internal network exploitation and lateral movement
"""

from airia import Agent, Task, tool
from mcp import Client as MCPClient
from typing import Dict, List, Any, Optional
import asyncio
import json

class InternalPentestAgent(Agent):
    """Agent specialized in internal penetration testing using NodeZero MCP"""

    def __init__(self):
        super().__init__(
            name="internal_pentest_agent",
            description="Performs internal network penetration testing and lateral movement",
            model="gpt-4"
        )
        self.nodezero_mcp = None
        self.attack_paths = []
        self.exploited_systems = []

    async def connect_mcp(self):
        """Connect to NodeZero MCP server"""
        self.nodezero_mcp = MCPClient("nodezero")
        await self.nodezero_mcp.connect()

        # Auto-discover available tools
        self.available_tools = await self.nodezero_mcp.list_tools()
        print(f"[Internal Pentest] Connected to NodeZero MCP with {len(self.available_tools)} tools")

    @tool
    async def network_discovery(self, entry_point: Dict) -> Dict[str, Any]:
        """Discover internal network from entry point"""
        discovery_results = await self.nodezero_mcp.call({
            "tool": "network_scan",
            "params": {
                "starting_point": entry_point.get("ip", "current"),
                "scan_type": "safe",
                "targets": ["192.168.0.0/16", "10.0.0.0/8", "172.16.0.0/12"]
            }
        })

        return {
            "discovered_hosts": discovery_results.get("hosts", []),
            "discovered_services": discovery_results.get("services", []),
            "network_topology": discovery_results.get("topology", {})
        }

    @tool
    async def vulnerability_assessment(self, targets: List[str]) -> Dict[str, List]:
        """Assess vulnerabilities on discovered targets"""
        vuln_results = await self.nodezero_mcp.call({
            "tool": "vulnerability_scan",
            "params": {
                "targets": targets,
                "scan_level": "production_safe",
                "check_types": ["misconfig", "weak_creds", "known_vulns", "privilege_escalation"]
            }
        })

        vulnerabilities = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": []
        }

        for vuln in vuln_results.get("vulnerabilities", []):
            severity = vuln.get("severity", "medium").lower()
            vulnerabilities[severity].append({
                "host": vuln.get("host"),
                "vulnerability": vuln.get("name"),
                "exploitable": vuln.get("exploitable", False),
                "description": vuln.get("description")
            })

        return vulnerabilities

    @tool
    async def exploit_vulnerability(self, target: str, vulnerability: str) -> Dict[str, Any]:
        """Safely exploit a vulnerability for proof of concept"""
        exploit_result = await self.nodezero_mcp.call({
            "tool": "exploit",
            "params": {
                "target": target,
                "vulnerability": vulnerability,
                "safe_mode": True,  # Always use safe mode in production
                "capture_proof": True
            }
        })

        if exploit_result.get("success"):
            self.exploited_systems.append({
                "target": target,
                "vulnerability": vulnerability,
                "access_level": exploit_result.get("access_level", "user")
            })

        return exploit_result

    @tool
    async def lateral_movement(self, compromised_host: str, target_host: str) -> Dict[str, Any]:
        """Attempt lateral movement from compromised host to target"""
        movement_result = await self.nodezero_mcp.call({
            "tool": "lateral_movement",
            "params": {
                "source": compromised_host,
                "target": target_host,
                "techniques": ["pass_the_hash", "psexec", "wmi", "ssh", "rdp"],
                "safe_mode": True
            }
        })

        if movement_result.get("success"):
            self.attack_paths.append({
                "from": compromised_host,
                "to": target_host,
                "technique": movement_result.get("technique_used"),
                "privileges": movement_result.get("privileges_gained")
            })

        return movement_result

    @tool
    async def privilege_escalation(self, target: str) -> Dict[str, Any]:
        """Attempt privilege escalation on target system"""
        escalation_result = await self.nodezero_mcp.call({
            "tool": "privilege_escalation",
            "params": {
                "target": target,
                "techniques": ["kernel_exploit", "service_misconfig", "weak_permissions", "scheduled_tasks"],
                "safe_mode": True
            }
        })

        return {
            "escalation_successful": escalation_result.get("success", False),
            "technique": escalation_result.get("technique_used"),
            "new_privileges": escalation_result.get("privileges_gained", "none")
        }

    @tool
    async def find_sensitive_data(self, compromised_systems: List[str]) -> Dict[str, List]:
        """Search for sensitive data on compromised systems"""
        data_results = await self.nodezero_mcp.call({
            "tool": "data_discovery",
            "params": {
                "systems": compromised_systems,
                "search_patterns": [
                    "*.sql", "*.db", "*.key", "*.pem",
                    "*password*", "*secret*", "*api*",
                    "*.xlsx", "*.csv"
                ],
                "safe_mode": True  # Only identifies, doesn't exfiltrate
            }
        })

        return {
            "databases": data_results.get("databases", []),
            "credentials": data_results.get("credentials", []),
            "sensitive_files": data_results.get("sensitive_files", []),
            "api_keys": data_results.get("api_keys", [])
        }

    @Task(description="Execute internal penetration test")
    async def penetration_test(self, entry_point: Dict, external_intel: Dict) -> Dict[str, Any]:
        """Main penetration testing task"""
        print(f"[Internal Pentest] Starting from entry point: {entry_point.get('type')}")

        # Phase 1: Network Discovery
        print("[Internal Pentest] Phase 1: Network Discovery")
        network = await self.network_discovery(entry_point)
        discovered_hosts = network["discovered_hosts"]

        if not discovered_hosts:
            return {"error": "No internal hosts discovered from entry point"}

        # Phase 2: Vulnerability Assessment
        print(f"[Internal Pentest] Phase 2: Scanning {len(discovered_hosts)} hosts")
        vulnerabilities = await self.vulnerability_assessment(discovered_hosts[:20])  # Limit for demo

        # Phase 3: Exploitation
        print("[Internal Pentest] Phase 3: Exploitation")
        exploited = []
        for vuln in vulnerabilities["critical"][:3]:  # Try top 3 critical vulns
            if vuln["exploitable"]:
                result = await self.exploit_vulnerability(vuln["host"], vuln["vulnerability"])
                if result.get("success"):
                    exploited.append(result)

        # Phase 4: Lateral Movement
        print("[Internal Pentest] Phase 4: Lateral Movement")
        if exploited:
            first_compromise = exploited[0]["target"]
            high_value_targets = self.identify_high_value_targets(network)

            for target in high_value_targets[:2]:  # Try 2 lateral movements
                await self.lateral_movement(first_compromise, target)

        # Phase 5: Privilege Escalation
        print("[Internal Pentest] Phase 5: Privilege Escalation")
        for system in self.exploited_systems:
            if system["access_level"] != "admin":
                await self.privilege_escalation(system["target"])

        # Phase 6: Data Discovery
        print("[Internal Pentest] Phase 6: Searching for Sensitive Data")
        compromised_hosts = [s["target"] for s in self.exploited_systems]
        sensitive_data = await self.find_sensitive_data(compromised_hosts) if compromised_hosts else {}

        # Compile results
        results = {
            "entry_point": entry_point,
            "discovered_network": network,
            "vulnerabilities": vulnerabilities,
            "exploited_systems": self.exploited_systems,
            "attack_paths": self.attack_paths,
            "sensitive_data_found": sensitive_data,
            "impact_assessment": self.assess_impact()
        }

        print(f"[Internal Pentest] Completed. Compromised {len(self.exploited_systems)} systems")
        return results

    def identify_high_value_targets(self, network: Dict) -> List[str]:
        """Identify high-value targets in the network"""
        high_value = []
        for host in network.get("discovered_hosts", []):
            # Look for domain controllers, databases, file servers
            if any(port in host.get("ports", []) for port in [389, 636, 3268]):  # LDAP/AD
                high_value.append(host["ip"])
            elif any(port in host.get("ports", []) for port in [1433, 3306, 5432]):  # Databases
                high_value.append(host["ip"])
            elif any(port in host.get("ports", []) for port in [445, 139]):  # File shares
                high_value.append(host["ip"])
        return high_value

    def assess_impact(self) -> Dict[str, Any]:
        """Assess the potential impact of the penetration test"""
        impact = {
            "systems_compromised": len(self.exploited_systems),
            "admin_access_gained": sum(1 for s in self.exploited_systems if s.get("access_level") == "admin"),
            "lateral_movements": len(self.attack_paths),
            "risk_level": "low"
        }

        # Calculate risk level
        if impact["admin_access_gained"] > 0:
            impact["risk_level"] = "critical"
        elif impact["systems_compromised"] > 5:
            impact["risk_level"] = "high"
        elif impact["systems_compromised"] > 0:
            impact["risk_level"] = "medium"

        return impact